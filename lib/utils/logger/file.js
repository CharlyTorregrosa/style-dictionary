/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

const chalk = require('chalk');
const { LOG_ICONS, LOG_MAP } = require('./consts');


/**
 * This will keep the diagnostics and logging of a building a file
 */
class FileLogger {
  constructor({ destination, format, allProperties=[], nested, deprecationMessage }) {
    this.destination = destination;
    this.format = format;
    this.allProperties = allProperties;
    this.status = 'notice';
    this.deprecationMessage = deprecationMessage;
    this.filteredReferences = [];
    this.nameCollisions = [];
    this.isEmpty = false;

    if (!nested) {
      this.findNameCollisions();
    }

    if (deprecationMessage) {
      this.status = `warn`;
    }

    if (allProperties.length === 0) {
      this.isEmpty = true;
      this.status = `warn`
    }
  }

  addTemplateDeprecation(template) {
    this.templateDeprecation = template;
    if (LOG_MAP[this.status] < LOG_MAP[`warn`]) {
      this.status = `warn`;
    }
  }

  addFilteredReference(reference) {
    if (this.filteredReferences.indexOf(reference) < 0) {
      this.filteredReferences.push(reference);
      this.status = `warn`;
    }
  }

  findNameCollisions() {
    const nameCollisionObj = {};
    this.allProperties.forEach((property) => {
      let {name} = property;
      if(!nameCollisionObj[name]) {
        nameCollisionObj[name] = [];
      }
      nameCollisionObj[name].push(property);
    });

    Object.keys(nameCollisionObj).forEach((name) => {
      if (nameCollisionObj[name].length > 1) {
        this.nameCollisions.push({
          name,
          collisions: nameCollisionObj[name]
        });
      }
    });
    if (this.nameCollisions.length > 0) {
      this.status = `warn`;
    }
  }

  title() {
    return chalk.bold(`${LOG_ICONS[this.status]} ${this.destination}`);
  }

  emptyFileMessage() {
    if (this.isEmpty) {
      return `* This file was not created because no properties were found. This is caused by filtering out all properties. Try changing or removing your filter.`
    }
  }

  templateDeprecationMessage() {
    if (this.templateDeprecation) {
      return `This file uses deprecated templates ${this.templateDeprecation}`
    }
  }

  filteredReferencesMessage() {
    if (this.filteredReferences.length > 0) {
      return `* ${this.filteredReferences.length} references were filtered out, output may be unexpected. Here are the references that are used but not defined in the file:\n` +
        this.filteredReferences.map(reference => {
          return `  * ${reference}`
        }).join(`\n`) +
        `\nThis is caused when combining a filter and 'outputReferences'.`;
    }
  }

  nameCollisionsMessage() {
    if (this.nameCollisions.length > 0) {
      return `* ${this.nameCollisions.length} Name collisions:\n` +
        this.nameCollisions.map(({name, collisions}) => {
          return `  * "${name}" was generated by: ${collisions.map(({path}) => path.join('.')).join(', ')}`
        }).join(`\n`) +
        `\nThis many-to-one issue is usually caused by some combination of:
* conflicting or similar paths/names in property definitions
* platform transforms/transformGroups affecting names, especially when removing specificity
* overly inclusive file filters`;
    }
  }

  messages() {
    return [
      this.deprecationMessage,
      this.emptyFileMessage(),
      this.templateDeprecationMessage(),
      this.filteredReferencesMessage(),
      this.nameCollisionsMessage(),
    ]
    .filter(str => !!str)
    .join(`\n`);
  }

  help() {
    return ``
  }
}

module.exports = FileLogger;